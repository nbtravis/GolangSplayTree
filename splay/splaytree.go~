package splay

import (
	"fmt"
	"strings"
	"math/rand"
)

type Node struct {
	key interface{}
	value interface{}
	parent *Node
	left *Node
	right *Node
}

// The SplayTree Interface must have a getter and setter method for a root node
// as well as an Ord method for comparing keys
type SplayTree interface {
	SetRoot(n *Node)
	GetRoot() *Node
	Ord(key1, key2 interface{}) int // 0 => LESS, 1 => EQUAL, 2 => GREATER
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// FIND /////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

func Search(ST SplayTree, key interface{}) *Node {
	return SearchNode(ST, key, ST.GetRoot())
}

func SearchNode(ST SplayTree, key interface{}, n *Node) *Node {
	if n == nil {
		return nil
	} else {
		switch ST.Ord(key, n.key) {
		case 0:
			return SearchNode(ST, key, n.left)
		case 1:
			return n
		case 2:
			return SearchNode(ST, key, n.right)
		}
		return nil
	}
}

func Find(ST SplayTree, key interface{}) interface{} {
	return FindNode(ST, key, ST.GetRoot())
}

func FindNode(ST SplayTree, key interface{}, n *Node) interface{} {
	if n == nil {
		return nil
	} else {
		switch ST.Ord(key, n.key) {
		case 0:
			return FindNode(ST, key, n.left)
		case 1:
			return n.value
		case 2:
			return FindNode(ST, key, n.right)
		}
		return nil
	}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// INSERTION ////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

func Insert(ST SplayTree, key, value interface{}) {
	if Search(ST, key) != nil {
		fmt.Println("Insertion Error: Key Already Exists")
		return
	}

	n := InsertNode(ST, key, value, ST.GetRoot())
	Splay(ST, n)
}

func InsertNode(ST SplayTree, key interface{}, value interface{}, n *Node) *Node {
	if n == nil {
		_n := new(Node)
		_n.key = key
		_n.value = value
		ST.SetRoot(_n)
		return ST.GetRoot()
	}
	
	switch ST.Ord(key, n.key) {
	case 0:
		if n.left == nil {
			n.left = new(Node)
			n.left.key = key
			n.left.value = value
			n.left.parent = n
			return n.left
		} else {
			return InsertNode(ST, key, value, n.left)
		}
	case 2:
		if n.right == nil {
			n.right = new(Node)
			n.right.key = key
			n.right.value = value
			n.right.parent = n
			return n.right
		} else {
			return InsertNode(ST, key, value, n.right)
		}
	}
	return nil
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// DELETION /////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

func Delete(ST SplayTree, key interface{}) {
	n := Search(ST, key)
	if n == nil {
		fmt.Println("Deletion Error: Key Does Not Exist")
		return
	} else {
		p := n.parent
		if n.left != nil {
			iop := InOrderPredecessor(n.left)
			Swap(n, iop)
			Remove(ST, iop)
		} else if n.right != nil {
			ios := InOrderSuccessor(n.right)
			Swap(n, ios)
			Remove(ST, ios)
		} else {
			Remove(ST, n)
		}

		if p != nil {
			Splay(ST, p)
		}
	}
}

// Swap properties of n1 and n2
func Swap(n1, n2 *Node) {
	n1.key, n2.key = n2.key, n1.key
	n1.value, n2.value = n2.value, n1.value
}

func Remove(ST SplayTree, n *Node) {
	var isRoot, isLeft bool
	isRoot = (n == ST.GetRoot())
	if isRoot != true {
		isLeft = (n == n.parent.left)
	}

	if isRoot != true {
		if isLeft == true {
			if n.left != nil {
				n.parent.left = n.left
				n.left.parent = n.parent
			} else if n.right != nil {
				n.parent.left = n.right
				n.right.parent = n.parent
			} else {
				n.parent.left = nil
			}
		} else {
			if n.left != nil {
				n.parent.right = n.left
				n.left.parent = n.parent
			} else if n.right != nil {
				n.parent.right = n.right
				n.right.parent = n.parent
			} else {
				n.parent.right = nil
			}			
		}
	}
	n = nil
}

// For the next two functions we are given that n is non-nil
func InOrderPredecessor(n *Node) *Node {
	if n.right == nil {
		return n
	} else {
		return InOrderPredecessor(n.right)
	}
}

func InOrderSuccessor(n *Node) *Node {
	if n.left == nil {
		return n
	} else {
		return InOrderSuccessor(n.left)
	}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// SPLAYING /////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
	
func Splay(ST SplayTree, n *Node) {
	for n != ST.GetRoot() {
		if n.parent == ST.GetRoot() {
			Zig(ST, n)
		}	else if n.parent.left == n && n.parent.parent.left == n.parent {
			ZigZigL(ST, n)
		} else if n.parent.right == n && n.parent.parent.right == n.parent {
			ZigZigR(ST, n)
		} else if n.parent.right == n && n.parent.parent.left == n.parent {
			ZigZagLR(ST, n)
		} else {
			ZigZagRL(ST, n)
		}
	}
}

func Zig(ST SplayTree, n *Node) {
	if n.parent.left == n {
		n.parent.left = n.right
		if n.right != nil {
			n.right.parent = n.parent
		}
		n.parent.parent = n
		n.right = n.parent
		n.parent = nil
	}	else {
		n.parent.right = n.left
		if n.left != nil {
			n.left.parent = n.parent
		}
		n.parent.parent = n
		n.left = n.parent
		n.parent = nil
	}
	ST.SetRoot(n)
}

func ZigZigL(ST SplayTree, n *Node) {
	gg := n.parent.parent.parent

	var isRoot, isLeft bool
	if gg == nil {
		isRoot = true
	} else {
		isRoot = false
		isLeft = (gg.left == n.parent.parent)
	}

	n.parent.parent.left = n.parent.right
	if n.parent.right != nil {
		n.parent.right.parent = n.parent.parent
	}
	n.parent.left = n.right
	if n.right != nil {
		n.right.parent = n.parent
	}
	n.parent.right = n.parent.parent
	n.parent.parent.parent = n.parent
	n.right = n.parent
	n.parent.parent = n
	n.parent = gg

	if isRoot == true {
		ST.SetRoot(n)
	} else if isLeft == true {
		gg.left = n
	} else {
		gg.right = n
	}	
}

func ZigZigR(ST SplayTree, n *Node) {
	gg := n.parent.parent.parent

	var isRoot, isLeft bool
	if gg == nil {
		isRoot = true
	} else {
		isRoot = false
		isLeft = (gg.left == n.parent.parent)
	}

	n.parent.parent.right = n.parent.left
	if n.parent.left != nil {
		n.parent.left.parent = n.parent.parent
	}
	n.parent.right = n.left
	if n.left != nil {
		n.left.parent = n.parent
	}
	n.parent.left = n.parent.parent
	n.parent.parent.parent = n.parent
	n.left = n.parent
	n.parent.parent = n
	n.parent = gg

	if isRoot == true {
		ST.SetRoot(n)
	} else if isLeft == true {
		gg.left = n
	} else {
		gg.right = n
	}
}

func ZigZagLR(ST SplayTree, n *Node) {
	gg := n.parent.parent.parent

	var isRoot, isLeft bool
	if gg == nil {
		isRoot = true
	} else {
		isRoot = false
		isLeft = (gg.left == n.parent.parent)
	}

	n.parent.parent.left = n.right
	if n.right != nil {
		n.right.parent = n.parent.parent
	}
	n.parent.right = n.left
	if n.left != nil {
		n.left.parent = n.parent
	}
	n.left = n.parent
	n.right = n.parent.parent
	n.parent.parent.parent = n
	n.parent.parent = n
	n.parent = gg

	if isRoot == true {
		ST.SetRoot(n)
	} else if isLeft == true {
		gg.left = n
	} else {
		gg.right = n
	}	
}

func ZigZagRL(ST SplayTree, n *Node) {
	gg := n.parent.parent.parent

	var isRoot, isLeft bool
	if gg == nil {		
		isRoot = true
	} else {
		isRoot = false
		isLeft = (gg.left == n.parent.parent)
	}

	n.parent.parent.right = n.left
	if n.left != nil {
		n.left.parent = n.parent.parent
	}
	n.parent.left = n.right
	if n.right != nil {
		n.right.parent = n.parent
	}
	n.right = n.parent
	n.left = n.parent.parent
	n.parent.parent.parent = n
	n.parent.parent = n
	n.parent = gg

	if isRoot == true {
		ST.SetRoot(n)
	} else if isLeft == true {
		gg.left = n
	} else {
		gg.right = n
	}	
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////// PRINTING TREE ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

func Print(ST SplayTree) {
	PrintNode(ST.GetRoot(), 0)
}

func PrintNode(n *Node, d int) {
	if n == nil {
		return
	}
	fmt.Println(strings.Repeat("-", 2*d), n.key, n.value)
	PrintNode(n.left, d+1)
	PrintNode(n.right, d+1)
}
